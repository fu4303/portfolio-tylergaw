---
layout: article
title: "You Can Build OS X Apps with JavaScript"
title_size: med
date: 2014-09-26
disqus_id: you-can-build-osx-apps-with-js
---

<p class="entry-intro">
  OS X Yosemite introduced JavaScript for Automation. This makes it possible to
  access all native OS X frameworks with JavaScript. I’ve been
  digging in to this new world and putting together <a href="https://github.com/tylergaw/js-osx-app-examples">examples</a>
  along the way. In this post I’ll explain the basics and step through building
  a small <a href="https://github.com/tylergaw/js-osx-app-examples/tree/master/ChooseAndDisplayImage.app">example app</a>.
</p>

<p>
  WWDC 2014 included a session on
  <a href="https://developer.apple.com/librarY/prerelease/mac/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/index.html">JavaScript for Automation</a>.
  The session introduced that in you would be able to use JavaScript in place of
  AppleScript to for automation. That alone is exciting news. Being able to automate
  repetitive tasks using AppleScript has been around a long time. AppleScript is
  not my definition of fun. Using a familiar syntax in its place is most welcome.
</p>
<p>
  During the session the presenter explains the Objective-C bridge. This is where
  things get super cool. The bridge allows you to import any Objective-C framework
  into JS applications. For example, if you want to build a GUI using standard OS X
  controls you would want to import Cocoa:
</p>
<pre><code class="language-javascript">ObjC.import("Cocoa");
</code></pre>
<p>
  The OS X <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/_index.html">Foundation</a>
  framework does what its name suggests. It provides the building blocks for
  OS X apps. The framework includes a massive amount of classes and protocols.
  <code>NSArray</code>, <code>NSURL</code>, <code>NSUserNotification</code>, and so on. You may not be familiar with
  those classes, but their names hint at what they do. Because of its importance,
  you can use its classes without needing to import it in new apps. They are
  available by default.
</p>
<p>
  As far as I can tell, you can use JavaScript to build anything that you can
  with Objective-C or Swift.
</p>
<h2>Building an example app</h2>
<p>
  The best way to get going with this is to jump in and build something. I’m
  going to describe how to build a small app that allows you display an image
  from your computer of your choosing.
</p>
<p>
  You can download the completed example from my <a href="https://github.com/tylergaw/js-osx-app-examples">example apps repo</a>.
</p>
<figure>
    <img src="assets/post-image-jsosx-example-01.jpg" alt="">
    <figcaption>
      A screenshot of the app we’ll build.
    </figcation>
</figure>
<p>
  Making up the app is; a window, text label, text input, and button. Or by their
  class names; <code>NSWindow</code>, <code>NSTextField</code>, <code>NSTextField</code>,
  and <code>NSButton</code>.
</p>
<p>
  Clicking the Choose an Image button will show an <code>NSOpenPanel</code> that allows you
  to select a file. We’ll configure the panel to restrict the selection to .jpg,
  .png, .gif.
</p>
<p>
  After selecting an image, we'll display it in the window. The window will
  resize to match the width and height of the image plus the height of the controls.
  We’ll also set a min width and height for the window to make sure the controls
  don’t get cut off.
</p>
<h3>Setting up the project</h3>
<p>
  Open the Apple Script Editor application located in <code>Applications > Utilities</code>.
  Script Editor ain’t the best editor I’ve ever used, but it’s necessary for now.
  It has a bunch of features that we need for building JS OS X apps. I’m not sure
  what goes on beyond the scenes, but it can compile and run your scripts as apps.
  It also creates a bunch of extra stuff like an info.plist file. My guess is there
  are ways to make other editors do the same, but I haven’t looked into it yet.
</p>
<p>
  Create a new document with <code>File > New</code> or <code>cmd + n</code>. The
  first thing we need to do, is save this document as an application.
  Save with <code>File > Save</code> or <code>cmd + s</code>.
  Don’t hit save right away. There are two options that are necessary to make
  this run as an application.
</p>
<figure>
    <img src="assets/post-image-jsosx-save.jpg" alt="">
    <figcaption>
      The Script Editor Save dialog with important fields highlighted
    </figcation>
</figure>
<p>
  Change the File Format to “Application”. Check the “Stay open after run handler”
  option. It’s important to set both of these options the first time you save the
  file, because as far as I can tell there is no way to set them later. If you
  miss one of these you’ll have to create a new document and copy your code over.
</p>
<p>
  If anyone knows a way to change the settings after creation, let me know.
</p>
<p>
  If you don’t select “Stay open after run handler” your app will open, flash for
  a split second, and then close. There is not much in the way of documentation for
  this stuff online. I only learned this detail after hours of forehead/keyboard merging.
</p>
<h3>Let’s make something do something!</h3>
<p>
  Add the following two lines to your script and then run it with <code>Script > Run Application</code>
  or <code>opt + cmd + r</code>.
</p>
<pre><code class="language-javascript">ObjC.import("Cocoa");
$.NSLog("Hi everybody!");
</code></pre>
<p>
  Not much happened. The only visible changes are in the menubar and dock. The app
  name along with <code>File</code> and <code>Edit</code> menus are in the menubar.
  You can see the app is running because it’s in your dock.
</p>
<p>
  Where is the “Hi everybody!”? What is with the dollar sign, what is this, jQuery?
  Quit the app the app with <code>File > Quit</code> or <code>cmd + q</code> and
  we’ll find out where that <code>NSLog</code> went.
</p>
<p>
  Open the Console app, <code>Applications > Utilities > Console</code>. Every
  application can log messages to the console. This console is not much different
  than Developer Tools in Chrome, Safari, or Firefox. The main difference is you
  use it for debugging applications instead of websites.
</p>
<p>
  There’s a whole lot of messages in the console. You can filter it down by
  typing “applet” into the search field in the top right corner. Leave “applet” in
  the search field and go back to Script Editor. Run the application again
  with <code>opt + cmd + r</code>.
</p>
<figure>
    <img src="assets/post-image-jsosx-console.jpg" alt="A screenshot showing a log message in Console.app">
</figure>
<p>
  Did you see it!? The message “Hi everybody!” should have logged to the console.
  If you didn’t see it, quit your application and run it again. A lot of times
  I forget to quit and the code doesn’t run again.
</p>
<h3>What about the dollar sign?</h3>
<p>
  The dollar sign is your access to the Objective-C bridge. Any time you need
  to access an objective-c class or constant, you use <code>$.ObjCThing</code> notation.
  There are a couple of other ways to use <code>$</code> that I’ll cover later.
</p>
<p>
  Console App and <code>NSLog</code> are indispensable tools, you’ll use them
  non-stop for debugging.
  For examples of logging things other than strings, have a look at my
  <a href="https://github.com/tylergaw/js-osx-app-examples/tree/master/NSLog.app">NSLog example</a>.
</p>
<h3>Creating the window</h3>
<p>
  Let’s make something we can see and interact with. Update your script to look
  like the following code:
</p>
<pre><code class="language-javascript">ObjC.import("Cocoa");

var styleMask = $.NSTitledWindowMask | $.NSClosableWindowMask | $.NSMiniaturizableWindowMask;
var windowHeight = 85;
var windowWidth = 600;
var window = $.NSWindow.alloc.initWithContentRectStyleMaskBackingDefer(
	$.NSMakeRect(0, 0, windowWidth, windowHeight),
	styleMask,
	$.NSBackingStoreBuffered,
	false
);

window.center;
window.title = "Choose and Display Image";
window.makeKeyAndOrderFront(window);
</code></pre>
<p>
  Once you have that in place, run the app. <code>opt + cmd + r</code>. Now we’re
  talking! With a small amount of code we’ve built an app that launches a window
  with a title that we can move, minimize, and close.
</p>
<figure>
  <img src="assets/post-image-jsosx-basic-window.jpg" alt="">
  <figcaption>A basic NSWindow created with JS</figcaption>
</figure>
<p>
  If you’ve never built an app with Objective-C or Cocoa–like me–a parts of this might
  look like a whole lot of gibberish. For me, that was due to the length of the
  method names. I enjoy descriptive names, but Cocoa takes it to the extreme.
</p>
<p>
  Looking past that though, this is JavaScript. This code looks just like code
  you’d write when building a website.
</p>
<p>
  What’s going on with that firt new line where we set <code>styleMask</code>.
  You use style masks to configure windows. Each style option says what it adds;
  a title, a close button, a minimize button. The options are constants. Use a pipe “|”
  to separate options. That pipe is a C bitwise <code>OR</code> operator.
  I’m not gonna to pretend I know what that means. I just know it’s
  needed to combine style options for a mask and that’s good enough for me.
</p>
<p>
  There are more style options. You can read about them in <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/WinPanel/Tasks/SettingWindowAppearance.html">the docs</a>.
  <code>NSResizableWindowMask</code> is one you’ll use. If you’re not
  sure, try adding it to the style mask to see what it does.
</p>
<p>
  There are a couple interesting things about syntax that you’ll need to remember.
  <code>$.NSWindow.alloc</code> calls the <code>alloc</code> method of <code>$.NSWindow</code>.
  Notice there are no parenthesis “()” after alloc. In JavaScript that is how you
  access a property, not how you call a method. In JS for OS X parenthesis are only
  allowed when calling a method if you pass arguments to it. If you use parenthesis
  with no arguments, you will get a runtime error. Check Console for errors when
  things don’t do what you think they should.
</p>
<p>
  The next thing is about that super long method name; <code>initWithContentRectStyleMaskBackingDefer</code>.
  Take a look at the <code>NSWindow</code> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#jumpTo_105">docs</a>
  for that method and you’ll notice it looks a bit different.
  <code>initWithContentRect:styleMask:backing:defer:</code>. In Objective-C you
  would create the same window we did like this:
</p>
<pre><code class="language-clike">NSWindow* window [[NSWindow alloc]
  initWithContentRect: NSMakeRect(0, 0, windowWidth, windowHeight)
  styleMask: styleMask,
  backing: NSBackingStoreBuffered
  defer: NO];
</code></pre>
<p>
  The thing to note are the colons “:” in the original signature. When you convert
  and Objective-C method to JS you remove the colons and capitalize the first letter
  following it. When you see two items in brackets “[]”, that is calling a method
  of a class. <code>[NSWindow alloc]</code> calls the <code>alloc</code> method
  of the <code>NSWindow</code>. For JS, convert those to dot-notation and parenthesis
  if necessary; <code>NSWindow.alloc</code>.
</p>
<p>
  I think the rest of the code to create and display the window is straightforward-enough.
  I’ll skip any more detailed description of it.
  It takes time and a lot of reading the docs and time to understand what is happening
  for each step along the way, but you’ll get there. As long as the window is
  showing up you’re doing great. Let’s do more.
</p>
<h3>Adding the controls</h3>
<p>
  We need a label, text field, and a button in this window. We’ll use <code>NSTextField</code>
  and <code>NSButton</code> to make that happen. Update your script with the
  following code and then run the app.
</p>
<pre><code class="language-javascript">ObjC.import("Cocoa");

var styleMask = $.NSTitledWindowMask | $.NSClosableWindowMask | $.NSMiniaturizableWindowMask;
var windowHeight = 85;
var windowWidth = 600;
var window = $.NSWindow.alloc.initWithContentRectStyleMaskBackingDefer(
	$.NSMakeRect(0, 0, windowWidth, windowHeight),
	styleMask,
	$.NSBackingStoreBuffered,
	false
);

var textFieldLabel = $.NSTextField.alloc.initWithFrame($.NSMakeRect(25, (windowHeight - 40), 200, 24));
textFieldLabel.stringValue = "Image: (jpg, png, or gif)";
textFieldLabel.drawsBackground = false;
textFieldLabel.editable = false;
textFieldLabel.bezeled = false;
textFieldLabel.selectable = true;

var textField = $.NSTextField.alloc.initWithFrame($.NSMakeRect(25, (windowHeight - 60), 205, 24));
textField.editable = false;

var singleBtn = $.NSButton.alloc.initWithFrame($.NSMakeRect(230, (windowHeight - 62), 150, 25));
singleBtn.title = "Choose an Image...";
singleBtn.bezelStyle = $.NSRoundedBezelStyle;
singleBtn.buttonType = $.NSMomentaryLightButton;

window.contentView.addSubview(textFieldLabel);
window.contentView.addSubview(textField);
window.contentView.addSubview(singleBtn);

window.center;
window.title = "Choose and Display Image";
window.makeKeyAndOrderFront(window);
</code></pre>
<p>
  If things worked you’ll now have a window with a label, text field, and button.
  You can’t type in the text field and the button doesn’t do anything, but hey
  we’re getting somewhere now.
</p>
<figure>
  <img src="assets/post-image-jsosx-controls.jpg" alt="">
  <figcaption>Label, field, and button elements in the window</figcaption>
</figure>
<p>
  What did we do in that addition? <code>textFieldLabel</code> and <code>textField</code>
  are similar. They’re both instances of <code>NSTextField</code>. We make them
  in a similar way as we made the window. When you see <code>initWithFrame</code>
  and <code>NSMakeRect</code>, it’s a good sign that the script is creating
  a UI element. <code>NSMakeRect</code> does what it says. It makes a rectangle
  with the give position and dimensions; <code>(x, y, width, height)</code>. That
  creates what’s called a struct in Objective-C. In JavaScript we’d refer to it as an
  object or hash or maybe dict. It’s a thing with keys and values.
</p>
<p>
  After creating the text fields we set a handful of properties on each to get the
  results we’re looking for. Cocoa doesn’t have anything like the html <code>label</code>
  element. For that we make our own by disabling editing and background styling.
</p>
<p>
  We’ll populate the text field programmatically, so disable editing on it as well.
  If we didn’t need that, creating a standard text field is a one-liner.
</p>
<p>
  <i>Thanks for reading</i>
</p>
