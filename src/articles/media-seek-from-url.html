---
layout: article
title: "Media Seek from URL"
title_size: med
date: 2014-09-17
disqus_id: media-seek-from-url
---

<p class="entry-intro">
  I recently had a need to be able to control the time of <code>audio</code>
  elements via a URL query string. I whipped up a bit of JavaScript to handle it.
  There’s a demo <a href="http://lab.tylergaw.com/media-seek-from-url/">here</a> and
  the source is <a href="https://github.com/tylergaw/media-seek-from-url">on GitHub</a>.
  I had fun figuring it out and thought maybe you’d enjoy reading about it.
  The following are details about why I needed it and the code I wrote.
</p>
<p>
  As with most projects, this one started with a problem that needed fixin’ The
  site this was for had a listing of audio tracks. Each list item included; the <code>audio</code>
  element, a title/link to the page for that track and a short description.
  Some of list items had extra links to the track’s page in the description.
</p>
<p>
  With this setup, the links to the track pages were causing the problem. Here’s
  what was happening; Users were pressing play on one of the tracks in the list.
  They would then click on one of the track’s links. That would take them away
  from the listing to that track’s page. The navigation would cause them to
  lose their place in the track they were listening to. The tracks were podcasts that
  ran from 45 to 70 minutes in length so losing your spot at 33 minutes and 45 seconds was annoying.
</p>
<p>
  This is where controlling the time of the <code>audio</code> element came into play.
  Clicking on a link should take the user to the track’s page and
  the track should resume playing where they left off.
</p>
<h2>Writing The Thing</h2>
<p>
  YouTube does this style of jumping around in videos via the URL. I think
  the query string style they use works well, so I took my cues from them. I decided
  I’d use URLs like:<br> <code>http://site.com/tracks/track-name?t=1h22m35s</code>.
</p>
<p>
  Two quick things about the code examples and descriptions:
</p>
<ol>
  <li>
    I wrote the original code for a specific project. The code I’ll be showing
    here is a modified version of that project’s code. The main difference
    is that there are no links to separate pages. I left that out because I
    felt like the interesting thing is not the navigation between pages.
  </li>
  <li>
    The examples only show <code>audio</code> elements, but you can use the same code
    with <code>video</code> elements.
  </li>
</ol>
<p>
  To get going, I didn’t want to get bogged down in run-of-the-mill stuff. I wanted something new.
  I knew that changing an <code>href</code> value of an <code>a</code> on click wouldn’t be challenging,
  so I started in the middle with something I didn’t know how to do.
  I started with parsing the query string.
</p>
<p>
  On page load, we run a function called <code>seekIfNeeded</code>. This
  function checks the <code>window.location.search</code> for the presence of
  the string “t=”. This determines if we need to bother trying to parse
  a time from the URL. This check is by no means fool-proof, but it gets the job done.
</p>
<pre class="line-numbers"><code class="language-javascript">function seekIfNeeded () {
  var q = window.location.search;

  if (q.indexOf('t=') > -1) {
    // Do parsing stuff
  }
}
</code></pre>
<p>
  Once it’s determined there’s a time to parse the good stuff starts.
  We need to; declare a couple convenience vars,
  bind a <code>canplay</code> event to the <code>audio</code>,
  convert the query string to seconds, and update <code>currentTime</code>
  property of the <code>audio</code>.
</p>
<pre class="line-numbers"><code class="language-javascript">function seekIfNeeded () {
  var q = window.location.search;

  if (q.indexOf('t=') > -1) {
    // Store the "1h34m27s" portion of the query string
    var timeString = q.split('=')[1],

      // Store a reference to the audo element with an id of "media"
      media = document.getElementById('media'),

      // Have we updated the time of the media element from the URL before?
      seekedFromURL = false;

    // We can only interact with audio elements when they are ready.
    // Listen for the "canplay" event to know when that is.
    media.addEventListener('canplay', function () {

      // The "canplay" event is triggered every time the audio element
      // is able to play. We only want to change the currentTime of
      // the audio the first time this event fires.
      if (!seekedFromURL) {

        // The currentTime property seeks to a value of seconds in
        // the media element.
        media.currentTime = secondsFromTimeParts(partsFromTimeString(timeString));

        // We've done the seeking, don't do this again.
        seekedFromURL = true;
      }
    });

    media.play();
  }
}
</code></pre>
<p>
  Things get interesting with the line that sets
  <code>media.currentTime</code>. It’s being set to the return value of the
  <code>secondsFromTimeParts</code> function. That function is given the
  return value of another function, <code>partsFromTimeString</code>.
</p>
<p>
  I’ll break down that line of code from the inside out. First <code>timeString</code>
  is a string like; “1h32m23s” or “15m10s” or “12s”. Any combination of hours,
  minutes, and seconds. Even though humans can figure out that the string
  represents time, the <code>audio</code>
  element isn’t going to understand it. The string is passed to <code>partsFromTimeString</code>.
  That function converts the string into an object of key/value pairs where the
  keys represent a part of the time and the values the amount of time for each part.
</p>
<pre class="line-numbers"><code class="language-javascript">function partsFromTimeString (str) {
  var parts = {h: 0, m: 0, s: 0};

  // Wrapping in a try to avoid an error in case someone gives the 't='
  // query string with no time. It'll just default to zero without it.
  try {

    // The regex match breaks the string into an array
    // like ["1h", "32m", "6s"]
    str.match(/[0-9]+[hms]+/g).forEach(function (val) {

      // Creates an array with two elements, the time and part
      // key like ["32", "m"]
      var part = val.match(/[hms]+|[0-9]+/g);
      parts[part[1]] = parseInt(part[0], 10);
    });
  }
  catch (e) {}

  return parts;
}
</pre></code>
<p>
  My first thought wasn’t to use a regular expression. I tend to avoid them because
  I only have a cursory knowledge of them. But the query string posed a problem. When trying
  to break up a string into specific parts, I look for patterns. A common letter or
  symbol or certain number or anything that repeats. A string like “1h32m23s”
  doesn’t have that, so I needed another pattern.
</p>
<p>
  The pattern that sticks out is; some number, followed by one of three letters.
  That letter could be “h”, “m”, or “s”. There’s no certainty
  that they would all be there or be in the same order. Ambiguity leads
  me down regular expression path. I suppose that’s what they’re there for?
</p>
<p>
  The <code>string.match</code> method returns an array of all matches found
  by a given regex. The regex <code>/[0-9]+[hms]+/g</code> looks at the string from left to right
  and says, “I want an integer with a value of 0 through 9, followed by the letter ‘h’, ‘m’, or ‘s’.”
  If the regex finds that numeric/alpha combination, it puts it in the array. Match.
</p>
<p>
  We’re getting closing to being able to separate the letters from the numbers.
  That’s what we’re after. Even though we want to separate them, we don’t want
  to disassociate them. Each letter gives us valuable information about the
  number. It tells us what part of the time it represents.
</p>
<p>
  The next step is to iterate over the array of number + letter combinations one by one.
</p>



<!-- <p>
    For this project I was working specifically with the <code>audio</code> element,
    but all of the code can be used with the <code>video</code> element as well.
</p> -->
