---
layout: article
title: "From Sass to PostCSS"
title_size: short
date: 2016-12-27
disqus_id: sass-to-postcss
---

<p class="entry-intro">
  Sass has been my go-to for years. But for a while now, I've wanted to try a new styling setup with PostCSS and the cssnext plugin. I love the idea of writing future CSS syntax today and using tooling more aligned with other tools I'm used to. This personal site is a perfect test bed to try this new setup.
</p>
<p>
  The first step I took was to take an inventory of my Sass usage. I needed to know what features I was using to make sure I found a replacement in the new setup. Here's a list of what I was using on this project:
</p>
<ul>
  <li>partial imports</li>
  <li>variables</li>
  <li>nesting</li>
  <li>mixins</li>
  <li>extend</li>
  <li>placeholder classes</li>
  <li><code>darken</code> and <code>rgba</code> color functions</li>
  <li>compression</li>
</ul>

<h2>Preparing</h2>
<p>
  Before getting to any new syntax or fun things I needed to do some yak shaving. The project was using typical file structure typical for using Sass. I used the leading underscore naming convention for partials. And included the required <code>scss</code> extension. I used two directories to loosely organize Sass files. <code>modules</code> housed Sass that didn't produce CSS. Things like variables, placeholder classes, and mixins. <code>partials</code> housed all CSS-producing Sass.
</p>
<p>
  This was the beginning file structure:
</p>
<pre><code class="language-none">css/
  scss/
    modules/
      _module.scss
      ...
    partials/
      _partial.scss
      ...
    tylergaw.scss
</code></pre>
<p>
  Each Sass partial gets imported in <code>tylergaw.scss</code>.
</p>

<pre><code class="language-scss">@import "modules/setup";
@import "modules/reset";
@import "modules/fonts";
</code></pre>

<p>
  I reorganized and renamed the files. I first changed the extension from <code>scss</code> to <code>css</code>. Instead of doing it a file at a time, I used a Bash script:
</p>
<pre><code class="language-bash">for f in *.scss; do git mv -- "$f" "${f%.scss}.css"; done;
</code></pre>

<p>
  Because the leading underscore is from the Sass world I also removed that. I couldn't figure a way to do it with Bash so I removed it from each file by hand. <i>(note to self; learn how to Bash better)</i>
</p>
<p>
  The last step was to move all the CSS files to the <code>modules</code> directory and remove the <code>partials</code> directory. I decided referring to all CSS as modules made more sense than trying to split them along the modules/partials line.
</p>

<h2>Build setup</h2>
<p>
  I started with the <a href="https://github.com/postcss/postcss-cli">PostCSS CLI</a>. I added a temporary build script to <code>package.json</code>:
</p>
<pre><code class="language-json">"scripts": {
  "postcss": "postcss -o public/css/tylergaw.css src/css/tylergaw.css"
}</code></pre>
<p>
  Without changing any styles I compiled the CSS:
</p>
<pre><code class="language-json">npm run postcss</code></pre>
<p>
  It worked! Sorta. I didn't get errors in the console, but it left me with a naked page on the <a href="http://css-naked-day.github.io/">wrong day</a>.
</p>
<figure>
  <img src="/articles/assets/post-image-postcss-1.png" alt="A screenshot of tylergaw.com missing all styles" />
  <figcaption>
    Results of the first PostCSS build
  </figcation>
</figure>
<p>
  With the build process functional I could now work to get the styles back in order.
</p>

<p>
   Looking at the console in Chrome I saw a stack of 404s. This revealed the first missing feature; <code>@import</code> inlining. With no changes <code>tylergaw.css</code> contains only <code>@import</code>s for each CSS module. The browser saw those and did what it knows to do. It attempted to load each module via an HTTP request. My build process only copies the single CSS file, not each module. Because of that, the browser couldn't find them.
</p>

<p>
  I could change the build process to make default <code>@import</code>s work, but that would be inefficient. I needed a replacement for Sass style <code>@import</code>s.
</p>

<h2>The first plugin</h2>
<p>
  To get Sass-style <code>@import</code>s I used the <code>postcss-import</code> plugin. After installing the module via npm I updated the build script to use it:
</p>

<pre><code class="language-json">"scripts": {
  "postcss": "postcss -u postcss-import -o public/css/tylergaw.css src/css/tylergaw.css"
}</code></pre>
<p>
  And ran the script again with <code>npm run postcss</code>. The single CSS file now contains all the modules and the site now has partial styling.
</p>

<figure>
  <img src="/articles/assets/post-image-postcss-2.png" alt="A screenshot of tylergaw.com with partial styles" />
  <figcaption>
    Results of the PostCSS build using postcss-import plugin
  </figcation>
</figure>

<h3>Will this be in a future CSS?</h3>
<p>
  The inlining of <code>@import</code>s was huge when it showed up in Sass. It's changed the way organize our styles for the better. I doubt this functionality will ever be native though. It seems like we'll always need a build step for this type of functionality.
</p>
<p>
  I imagine the <code>postcss-import</code> plugin will be a staple for all my future PostCSS setups. My guess is this will be true for other folks too. This quote from the plugin author sounds right on:
</p>
<blockquote>
  <p>
    This plugin should probably be used as the first plugin of your list. This way, other plugins will work on the AST as if there were only a single file to process, and will probably work as you can expect.
  </p>
  <cite>
    <a href="https://github.com/postcss/postcss-import#postcss-import">
      postcss-import
    </a>
  </cite>
</blockquote>



<hr>



<p>
  I Killed prefixed.css. I built this site before Autoprefixer was a thing. I also only needed to prefix a handful of properties. So, I wrote a few Sass mixins to hanle the vendor prefixing. This was the easiest thing to remove. Because cssnext handles necessary vender prefixing, I could safely remove all uses of the prefix mixins I'd created.
</p>
<p>
  I added PostCSS and cssnext and removed my prefix mixins, but I'm still looking at this:
</p>
<figure>
  <img src="" alt="Screenshot of a partially styled tylergaw.com">
</figure>
<p>
  There's a foundational piece missing. Variables. I leaned on Sass variables for this project. Without them, there is no background or text color. This is the point that I needed to switch my brain from Sass to a future CSS.
</p>
<p>
  I took this step one rule at a time. The first thing I needed to figure out was the <code>body</code> rule. If I could get that together everything else would be a copy.
</p>
<h2>Nothing works (the way you expect it to)</h2>
<p>
  Not dogging anyone with this observation. If you go down this path things are not going to work like you're used to or you expect. This is a new frontier. Plan accordingly.
</p>

<p>
  Converted Sass style variables to CSS. <code>$foo</code> to <code>--foo</code>.
</p>

<p>
  Updated nesting syntax. Basic nesting requires the an ampersand "&" like <code>.parent { & .child {}}</code>. Media queries work without the "&".
</p>

<p>
  One thing that surprised me about the nesting syntax is that things like <code>&:hover</code>, <code>&::after</code> worked the same way as Sass. That's when it clicked for me that requiring the ampersand for all nesting is because it's a placeholder for the parent selector.
</p>

<p>
  Using <code>rgba()</code> with hex or variable values like <code>rgba($blue, 0.5)</code> is another Sass feature I use frequently. The outcome is possible with CSS, but we now use the <code>color()</code> function.
</p>
<pre><code class="language-css">color(var(--offwhite) alpha(10%));</code></pre>
<p>
  The <code>color</code> function is powerful and provides quite a few <a href="https://github.com/postcss/postcss-color-function#list-of-color-adjuster">adjusters</a>
</p>
<p>
  You can use multiple color adjusters too;
</p>
<pre><code class="language-css">color(var(--white) shade(40%) alpha(10%))</code></pre>

<h2>Move aside extend, here comes apply</h2>
<p>
  I was using <code>@extend</code> for common styles throughout the site. You can store a set of properties and use <code>@apply</code> to achieve the same outcome.
</p>

<p>
  Here's one way I was using <code>@extend</code> with placeholder classes:
</p>
<pre><code class="language-scss">%futura {
  font-family: 'futura-pt', helvetica, sans-serif;
}

%futura-heading {
  @extend %futura;
  font-weight: 700;
  line-height: 1.1;
  text-transform: uppercase;
}

.my-heading {
  @extend %futura-heading;
}</code></pre>

<p>
  and how it looks converted to CSS:
</p>
<pre><code class="language-css">:root {
  ...

  --futura: {
    font-family: 'futura-pt', helvetica, sans-serif;
  };

  --futura-heading: {
    @apply --futura;
    font-weight: 700;
    line-height: 1.1;
    text-transform: uppercase;
  };
}

.my-heading {
  @apply --futura-heading;
}</code></pre>

<p>
  It's the same amount of code with slightly different syntax.
</p>

<p>
  Mixins with arguments. For my Projects page I give a different background color to each project block. To make this easier on myself, I used a Sass mixin that takes a single argument. The color I want:
</p>
<pre><code class="language-scss">@mixin project-block ($c) {
  background-color: $c;

  a {
    color: $c;

    &:hover {
      background-color: $c;
      color: $offwhite);
    }
  }
}
...
.p-jribbble {
  @include project-block(#ff0066);
}</code></pre>
<p>
  At the time of this writing, I couldn't find a way to mimic this functionality. Custom property sets with <code>@apply</code> aren't functions, so you can't provide arguments. Looking at the <a href="https://drafts.csswg.org/css-extensions/#declarative-custom-selector">draft spec</a> for custom selectors, it <i>looks</i> like it may be a way to do some argument magic in the future, but today I couldn't see a way to make it work.
</p>
<p>
  This doesn't mean all is lost. I did find a way to make each rule shorter. Here's an example of what each rule looks like now:
</p>
<pre><code class="language-css">.p-jribbble,
.p-jribbble a:matches(:hover, :focus) {
  background-color: var(--color-jrb);

  & a {
    color: var(--color-jrb);
  }
}</code></pre>
<p>
  The color variables are defined in a <code>:root</code> scope earlier in the file. The new feature in use here is the <code>matches</code> <a href="https://drafts.csswg.org/selectors-4/#matches">pseudo class</a>. For these purposes it's letting me write a shorter selector for each project block.
</p>
<p>
  The code above compiles to:
</p>
<pre><code class="language-css">.p-jribbble,
.p-jribbble a:hover,
.p-jribbble a:focus {
  background-color: #ff0066
}

.p-jribbble a,
.p-jribbble a:hover a,
.p-jribbble a:focus a {
  color: #ff0066;
}</code></pre>
<p>
  The last two selectors that include <code>a a:hover</code> won't match any elements. They're unecessary, but aside from a few more bytes they don't hurt anything. I preferred to nest the <code>a</code> selector for code readability.
</p>
<h2>More Improvements</h2>
<p>
  Since I'm using PostCSS I'm taking advantage of more plugins. I used <a href="https://github.com/hail2u/node-css-mqpacker">css mqpacker</a> to combine media queries that share the same query. I also used <a href="">cssnano</a> for further optimization.
</p>

{% include thanks-for-reading.html %}
