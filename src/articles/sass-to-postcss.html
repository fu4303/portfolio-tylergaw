---
layout: article
title: "Moving from Sass to PostCSS"
title_size: short
date: 2016-12-30
disqus_id: sass-to-postcss
---

<p class="entry-intro">
  Sass has been my go-to for styling for years. It's been taken much burden off writing and organizing styles. In the last few years alternatives have shown up on the scene. Recently I've been wanting to try out a new styling setup using just CSS with the aid of PostCSS to fill Sass's big shoes. I also using this opportunity to use cssnext. To start using in-progress CSS specifications now.
</p>

<p>
  The first thing I did was take an inventory of what Sass features I'm using on this project. Here's what I'm working with:
</p>
<ul>
  <li>imports</li>
  <li>underscore naming convention</li>
  <li>$ - variables</li>
  <li>nesting</li>
  <li>mixins</li>
  <li>extends (maybe I shouldn't use this)</li>
  <li>placeholder classes</li>
  <li>color functions (darken, lighten, rgba with hex and variable values)</li>
  <li>compression</li>
</ul>

<h2>The Setup</h2>
<p>
  For my purposes, I want the least amount of tooling. For now I'm sticking with the PostCSS CLI. I added the command to this project's Procfile, and we're good to go.
</p>

<p>
  I wasn't sure about best practices for naming directories and files. I realized I'd been using organization and naming conventions suggested by Sass. Those likely aren't valid or needed in this new world.
</p>
<p>
  I needed to rename all the files. Changing the <code>scss</code> extension to <code>css</code> was easy enough after a quick search:
</p>
<pre><code class="language-javascript">for f in *.scss; do git mv -- "$f" "${f%.scss}.css; done;"
</code></pre>
<p>
  Removing the leading underscore. That was a pain. I ended up doing it manually. Reminder to self; learn how to Bash better.
</p>
<p>
  This left me with a naked page on the <a href="">wrong day</a>. From here, the goal was to get the site styles back to where they were before.
</p>
<p>
  Before I could see any styling, I needed <code>@import</code> to function in the way I needed. That is the non-standard way of inlining imported CSS files. <code>postcss-import</code> has this covered. Judging by this quote, the plugin author knows this is where folks will land.
</p>
<blockquote>
  <p>
    This plugin should probably be used as the first plugin of your list. This way, other plugins will work on the AST as if there were only a single file to process, and will probably work as you can expect.
  </p>
  <cite><a href="https://github.com/postcss/postcss-import#postcss-import">postcss-import</a></cite>
</blockquote>
<p>
  This is a killer feature that Sass (and Less and Stylus) brought about. This is the type of feature that tells me we'll be using some type of build tooling for styling on the Web indefinitely. I don't want the browser making dozens of requests. But I want to organize my code into logical chunks. We can work without this, but who wants to?
</p>
<p>
  Oh boy. When I installed, configured, ran <code>postcss</code> with PostCSS import for the first time...jaw on floor. It worked exactly as it said and it was excellent.
</p>
<p>
  I Killed prefixed.css. I built this site before Autoprefixer was a thing. I also only needed to prefix a handful of properties. So, I wrote a few Sass mixins to hanle the vendor prefixing. This was the easiest thing to remove. Because cssnext handles necessary vender prefixing, I could safely remove all uses of the prefix mixins I'd created.
</p>
<p>
  OK. I added PostCSS and cssnext and removed my prefix mixins, but I'm still looking at this:
</p>
<figure>
  <img src="" alt="Screenshot of a partially styled tylergaw.com">
</figure>
<p>
  There's a foundational piece missing. Variables. I leaned on Sass variables for this project. Without them, there is no background or text color. This is the point that I needed to switch my brain from Sass to a future CSS.
</p>
<p>
  I took this step one rule at a time. The first thing I needed to figure out was the <code>body</code> rule. If I could get that together everything else would be a copy.
</p>
<h2>Nothing works (the way you expect it to)</h2>
<p>
  Not dogging anyone with this observation. If you go down this path things are not going to work like you're used to or you expect. This is a new frontier. Plan accordingly.
</p>

<p>
  Converted Sass style variables to CSS. <code>$foo</code> to <code>--foo</code>.
</p>

<p>
  Updated nesting syntax. Basic nesting requires the an ampersand "&" like <code>.parent { & .child {}}</code>. Media queries work without the "&".
</p>

<p>
  One thing that surprised me about the nesting syntax is that things like <code>&:hover</code>, <code>&::after</code> worked the same way as Sass. That's when it clicked for me that requiring the ampersand for all nesting is because it's a placeholder for the parent selector.
</p>

<p>
  Using <code>rgba()</code> with hex or variable values like <code>rgba($blue, 0.5)</code> is another Sass feature I use frequently. The outcome is possible with CSS, but we now use the <code>color()</code> function.
</p>
<pre><code class="language-javascript">color(var(--offwhite) alpha(10%));</code></pre>
<p>
  The <code>color</code> function is powerful and provides quite a few <a href="https://github.com/postcss/postcss-color-function#list-of-color-adjuster">adjusters</a>
</p>
<p>
  You can use multiple color adjusters too;
</p>
<pre><code class="language-javascript">color(var(--white) shade(40%) alpha(10%))</code></pre>

<h2>Move aside extend, here comes apply</h2>
<p>
  I was using <code>@extend</code> for common styles throughout the site. You can store a set of properties and use <code>@apply</code> to achieve the same outcome.
</p>

<p>
  Here's one way I was using <code>@extend</code> with placeholder classes:
</p>
<pre><code class="language-javascript">%futura {
  font-family: 'futura-pt', helvetica, sans-serif;
}

%futura-heading {
  @extend %futura;
  font-weight: 700;
  line-height: 1.1;
  text-transform: uppercase;
}

.my-heading {
  @extend %futura-heading;
}</code></pre>

<p>
  and how it looks converted to CSS:
</p>
<pre><code class="language-javascript">:root {
  ...

  --futura: {
    font-family: 'futura-pt', helvetica, sans-serif;
  };

  --futura-heading: {
    @apply --futura;
    font-weight: 700;
    line-height: 1.1;
    text-transform: uppercase;
  };
}

.my-heading {
  @apply --futura-heading;
}</code></pre>

<p>
  It's the same amount of code with slightly different syntax. I haven't dug in to the output the cssnext polyfill generates yet. I'm not sure if this produces more, less, or the same amount of CSS as <code>extend</code>. For my use case now, I'm not too concerned since this is a small site.
</p>

<p>
  Mixins with arguments. For my Projects page I give a different background color to each project block. To make this easier on myself, I used a Sass mixin that takes a single argument. The color I want:
</p>
<pre><code class="language-javascript">@mixin project-block ($c) {
  background-color: $c;

  a {
    color: $c;

    &:hover {
      background-color: $c;
      color: $offwhite);
    }
  }
}
...
.p-jribbble {
  @include project-block(#ff0066);
}</code></pre>
<p>
  At the time of this writing, I couldn't find a way to mimic this functionality. Custom property sets with <code>@apply</code> aren't functions, so you can't provide arguments. Looking at the <a href="https://drafts.csswg.org/css-extensions/#declarative-custom-selector">draft spec</a> for custom selectors, it <i>looks</i> like it may be a way to do some argument magic in the future, but today I couldn't see a way to make it work.
</p>
<p>
  This doesn't mean all is lost. I did find a way to make each rule shorter. Here's an example of what each rule looks like now:
</p>
<pre><code class="language-javascript">.p-jribbble,
.p-jribbble a:matches(:hover, :focus) {
  background-color: var(--color-jrb);

  & a {
    color: var(--color-jrb);
  }
}</code></pre>
<p>
  The color variables are defined in a <code>:root</code> scope earlier in the file. The new feature in use here is the <code>matches</code> <a href="https://drafts.csswg.org/selectors-4/#matches">pseudo class</a>. For these purposes it's letting me write a shorter selector for each project block.
</p>
<p>
  The code above compiles to:
</p>
<pre><code class="language-javascript">.p-jribbble,
.p-jribbble a:hover,
.p-jribbble a:focus {
  background-color: #ff0066
}

.p-jribbble a,
.p-jribbble a:hover a,
.p-jribbble a:focus a {
  color: #ff0066;
}</code></pre>
<p>
  The last two selectors that include <code>a a:hover</code> won't match any elements. They're unecessary, but aside from a few more bytes they don't hurt anything. I preferred to nest the <code>a</code> selector for code readability.
</p>
<h2>More Improvements</h2>
<p>
  Since I'm using PostCSS I can take advantage of more plugins. I used mq packer and css nano to reduce the overall files size.
</p>

{% include thanks-for-reading.html %}
